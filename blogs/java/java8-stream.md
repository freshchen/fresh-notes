# Java8新特性之Stream



集合是Java中使用最多的API,。比如，以下SQL查询语句就可以选出热量较低的菜肴名
称：SELECT name FROM dishes WHERE calorie < 400。你看，你不需要实现如何
根据菜肴的属性进行筛选（比如利用迭代器和累加器），你只需要表达你想要什么,要是要处理大量元素又该怎么办呢？为了提高性能，你需要并行处理，并利用多核架构。
但写并行代码比用迭代器还要复杂，而且调试起来也够受的！



流是Java API的新成员，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不
是临时编写一个实现）。就现在来说，你可以把它们看成遍历数据集的高级迭代器。此外，流还可以透明地并行处理，你无需写任何多线程代码了



69页例子



因为filter、sorted、map和collect等操作是与具体线程模型无关的高层次构件，所以
它们的内部实现可以是单线程的，也可能透明地充分利用你的多核架构！在实践中，这意味着你
用不着为了让某些数据处理任务并行而去操心线程和锁了，Stream API都替你做好了！
图4-



Java 8中的Stream API可以让你写出这样的代码：

声明性——更简洁，更易读

可复合——更灵活

可并行——性能更好





。集合讲的是数据，流讲的是计算

流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集
合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。



粗略地说，集合与流之间的差异就在于什么时候进行计算，粗略地说，集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，
它包含数据结构中目前所有的值



请注意，和迭代器类似，流只能遍历一次





集合和流的另一个关键区别在于它们遍历数据的方式。使用Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。 相反，
Streams库使用内部迭代——它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出
一个函数说要干什么就可以了



可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作



以下是你应从本章中学到的一些关键概念。
 流是“从支持数据处理操作的源生成的一系列元素”。
 流利用内部迭代：迭代通过filter、map、sorted等操作被抽象掉了。
 流操作有两类：中间操作和终端操作。
 filter和map等中间操作会返回一个流，并可以链接在一起。可以用它们来设置一条流
水线，但并不会生成任何结果。
 forEach和count等终端操作会返回一个非流的值，并处理流水线以返回结果。
 流中的元素是按需计算的。





筛选和切片
在本节中，我们来看看如何选择流中的元素：用谓词筛选，筛选出各不相同的元素，忽略流
中的头几个元素，或将流截短至指定长度。



用谓词筛选

Streams接口支持filter方法（你现在应该很熟悉了）。该操作会接受一个谓词（一个返回
boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流



流还支持一个叫作distinct的方法，去重，它会返回一个元素各异（根据流所生成元素的
hashCode和equals方法实现）的流



流支持limit(n)方法，该方法会返回一个不超过给定长度的流。所需的长度作为参数传递
给limit。如果流是有序的，则最多会返回前n个元素



流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一
个空流。请注意，limit(n)和skip(n)是互补的！例如，下面的代码将跳过超过300卡路里的头
两道菜，并返回剩下的。



一个非常常见的数据处理套路就是从某些对象中选择信息。比如在SQL里，你可以从表中选
择一列。Stream API也通过map和flatMap方法提供了类似的工具

使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一
个新版本”而不是去“修改”）



使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所
有使用map(Arrays::stream)时生成的单个流都被合并起来，即扁平化为一个流



另一个常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性。Stream
API通过allMatch、anyMatch、noneMatch、findFirst和findAny方法提供了这样的工具



这样的查询可以被归类为归约操作
（将流归约成一个值）。用函数式编程语言的术语来说，这称为折叠（fold），因为你可以将这个操
作看成把一张长长的纸（你的流）反复折叠成一个小方块，而这就是折叠操作的结果。



reduce接受两个参数：
 一个初始值，这里是0；
 一个BinaryOperator<T>来将两个元素结合起来产生一个新值，这里我们用的是
lambda (a, b) -> a + b。





诸如map或filter等操作会从输入流中获取每一个元素，并在输出流中得到0或1个结果。
这些操作一般都是无状态的：它们没有内部状态

相反，诸如sort或distinct等操作一开始都和filter和map差不多——都是接受一个
流，再生成一个流（中间操作），但有一个关键的区别。从流中排序和删除重复项时都需要知
道先前的历史。例如，排序要求所有元素都放入缓冲区后才能给输出流加入一个项目，这一操
作的存储要求是无界的。要是流比较大或是无限的，就可能会有问题（把质数流倒序会做什么
呢？它应当返回最大的质数，但数学告诉我们它不存在）。我们把这些操作叫作有状态操作



但不要担心，Stream API还提供了原始类
型流特化，专门支持处理数值流的方法。Java 8引入了三个原始类型特化流接口来解决这个问题：IntStream、DoubleStream和
LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。



要把原始流转换成一般流（每个int都会装箱成一个
Integer），可以使用boxed方法





你可以使用静态方法Stream.of，通过显式值创建一个流。它可以接受任意数量的参数。例
如，以下代码直接使用Stream.of创建了一个字符串流。然后，你可以将字符串转换为大写，再
一个个打印出来：
Stream<String> stream = Stream.of("Java 8 ", "Lambdas ", "In ", "Action");
stream.map(String::toUpperCase).forEach(System.out::println);







总而言之，流的使用一般包括三件事：
 一个数据源（如集合）来执行一个查询；
 一个中间操作链，形成一条流的流水线；
 一个终端操作，执行流水线，并能生成结果。



流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映
射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一
个新版本”而不是去“修改”）





，flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接
起来成为一个流。



anyMatch、allMatch和noneMatch这三个操作都用到了我们所谓的短路，这就是大家熟悉
的Java中&&和||运算符短路在流中的版本。



表5-1 中间操作和终端操作
操 作 类 型 返回类型 使用的类型/函数式接口 函数描述符
filter 中间 Stream<T> Predicate<T> T -> boolean
distinct 中间
(有状态无界)
Stream<T>
skip 中间
(有状态有界)
Stream<T> long
limit 中间
(有状态有界)
Stream<T> long
map 中间 Stream<R> Function<T, R> T -> R
flatMap 中间 Stream<R> Function<T, Stream<R>> T -> Stream<R>
sorted 中间
(有状态无界)
Stream<T> Comparator<T> (T, T) -> int
anyMatch 终端 boolean Predicate<T> T -> boolean
noneMatch 终端 boolean Predicate<T> T -> boolean
allMatch 终端 boolean Predicate<T> T -> boolean
findAny 终端 Optional<T>
findFirst 终端 Optional<T>
forEach 终端 void Consumer<T> T -> void
collect 终端 R Collector<T, A, R>
reduce 终端
(有状态有界)
Optional<T> BinaryOperator<T> (T, T) -> T
count 终端 long





Java 8引入了三个原始类型特化流接口来解决这个问题：IntStream、DoubleStream和
LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。

将流转换为特化版本的常用方法是mapToInt、mapToDouble和mapToLong。这些方法和前
面说的map方法的工作方式一样，只是它们返回的是一个特化流，而不是Stream<T>。

要把原始流转换成一般流（每个int都会装箱成一个
Integer），可以使用boxed方法，

求和的那个例子很容易，因为它有一个默认值：0。但是，如果你要计算IntStream中的最
大元素，就得换个法子了，因为0是错误的结果。如何区分没有元素的流和最大值真的是0的流呢？
前面我们介绍了Optional类，这是一个可以表示值存在或不存在的容器。Optional可以用
Integer、String等参考类型来参数化。对于三种原始流特化，也分别有一个Optional原始类
型特化版本：OptionalInt、OptionalDouble和OptionalLong





。Java 8引入了两个可以用于IntStream和LongStream的静态方法，帮助生成这种范围：
range和rangeClosed



你可以使用静态方法Stream.of，通过显式值创建一个流

你可以使用静态方法Arrays.stream从数组创建一个流

你可以使用Files.lines得到一个流，其中的每个元素都是给定文件中的一行



Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate。
这两个操作可以创建所谓的无限流：



















**在 JVM 的后台，使用通用的 fork/join 池来完成上述功能，该池是所有并行流共享的。默认情况，fork/join 池会为每个处理器分配一个线程。假设你有一台16核的机器，这样你就只能创建16个线程。对 CPU 密集型的任务来说，这样是有意义的，因为你的机器确实只能执行16个线程。但是真实情况下，不是所有的任务都是 CPU 密集型的，这就会导致线程因IO等待浪费CPU资源，降低系统处理性能。 这就解释了上面128个业务线程中只有2个线程处于RUNNABLE状态，而其他126个业务线程都在等待的原因。->因为业务线程内部使用了parallelStream处理业务数据，所以所有业务线程内部都需要使用jvm for/join线程进行业务处理，因为只有jvm fork/join线程，所以同时只能处理两个业务线程的执行逻辑**